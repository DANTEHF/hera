现在的产品类型设计是这样的结构，并且数据还存放在每一个订单中的具体项目中
const productSchema = new Schema({
  type: String,
  name: String,
  sizes: [String],
  unit: String,
  sizeUnit: String,
  countUnit: String,
  convert: Number, // 折合数量级
  convertUnit: String, // 折合单位

  pinyin: String, // 产品名称的拼音
});

为了减少查询时候的麻烦，我最初的选择是将这部分数据直接存放到了所有使用到他的表
中，这样子产生的问题是如果更新规格的话，没有如何变化的根据，我只能根据理论上的
name+size是唯一的来变化，但是这样子更新很不方便。另一方面，也是最大的麻烦，就是
前台在进行某些处理的时候，也是要通过name+size，而size有时候还会是空的，也要特殊
处理，这些都让我决定改进这个结构。
这次改变将沿用原本的思想，但是加入一个 id 来标记对应的内容。

原本要从类型名称中推断出如何换算就是一个错误的决定，仅存的意义只是为了能少重复
一些输入，哪怕这些输入其实可以在录入的时候帮用户推断出来。

新的模型中将这个问题解决了。

针对有些没有规格的产品，我还没有很好的思路要怎么处理，关键是，我要想一下，为什么
要特殊处理，以及如果特殊处理我要怎么做，如果不特殊处理我应该怎么做？

因为我们这里不考虑一直嵌套的问题，所以我们进行特殊处理，就只有规格会出现有无的现象，
如果没有规格，我们在选择的时候禁用掉对规格的检查，灰化处理，以及禁止他的使用


// 这是目前给出的初步原型，接下去是试验一下这个原型在功能上会有什么缺失
const productSchema = new Schema({
    type: String,
    name: String,
    sizes: [{
        name: String,
        unit: String,
        scale: { type: Number, default: 1 }, // 比例
        pinyin: String,
    }],
    unit: String,
    pinyin: String,
});


productSchema.index({ type: 1, name: 1 }, { unique: true });
productSchema.index({ type: 1, name: 1, "sizes.name": 1 }, { unique: true });

如果需要支持排序的话，因为数量并不会太多，所以总是重新设置这个数据，而不是使用mongo中的方法。
包括更新等操作

在界面上应该给出以下的效果：
1. 能够支持拖拽排序
2. 能够支持预览在其他地方中某个修改会产生的效果
3. 在界面上进行数据校验，让用户直接意识到某些问题

产品本身代表了一个计价的基本单位，然后通过规格中的 scale 进行换算。
具体来说是这样子的，对于没有规格的产品（对我们系统来说没必要设置规格的产品），直接以产品的单位进行计算即可。
而有规格的产品，比如说钢管。
规格中的单位就是根，而转换的多少，就取决于scale，这里scale和name会有重叠的地方，scale是1.6，name是1.6米，但是这里不应该当做是一回事，这是我原本犯的错。
油漆是一个比较有趣的例子，也是为什么要做出这个改变的推力。
原本油漆的单位都是桶，这个显然是不好的，一桶到底是多少油漆，你也不知道。
这一点突然让我想到，油漆不同牌子价格不是也不一样么，好在，这里我不需要考虑这个问题。我只需要考虑它的重量，也就是说。
产品这边的单位可以设置为升或者千克，然后规格那边进行转换。
这里会发现另一个问题，当我们想把产品的基本单位进行修改的时候，所有数据都要修改，不过同样不成问题，只是有潜在的精度问题。
如果需要考虑精度的时候可以想一下。

这里涉及的一个问题是，无规格的产品转换成有规格的产品之后，原本的无规格产品要怎么转换？
从数据层面上看，已经没有办法区分了，所以肯定是转换成某一种有规格的产品，这里遇到的时候另行考虑。
无规格的产品进行关联的时候是关联产品的 ObjectId。不过这种不一致性会对我们列举的时候产生一些麻烦，这里先不管，这点麻烦不算什么。
